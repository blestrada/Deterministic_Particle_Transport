import numpy as np
import matplotlib.pyplot as plt
import math

""" Description of Su-Olson Radiative Transfer Benchmark Problem
The Su-Olson problem consists of a one-dimensional, half-space, non-equilibrium Marshak wave.
The radiative transfer model is a one-group diffusion approximation with a finite radiation source boundary condition, where
the radiative and material fields are out of equilibrium. As the energy density of the radiation field increases, energy is transfered to the material. 
"""

# Global Physics Data
c = 3.0e10  # cm/s
h = 4.1356675e-18  # KeV.s
pi = 3.14159265359
invc = 1.0 / c
sb = 2.0 * pi ** 5 / (15.0 * h ** 3 * c ** 2)  # keV^-3.cm^-2.s^-1 (flux-like)
a = 4.0 * sb / c  # keV^-3.cm^-3 (density-like)

# User Inputs
Nx = 5
Nmu = 2
Nt = 5
Nxi = 1
xsize = 20.0
user_dx = 1.0
dt = 1E-13
ns = 10000


# Global mesh data
ncells = int(math.ceil(xsize / float(user_dx)))
dx = xsize / float(ncells)
cellpos = np.arange(0.5 * dx, xsize, dx)
nodepos = np.linspace(0.0, xsize, ncells + 1)
temp = np.zeros(ncells)
radtemp = np.zeros(ncells)

# Global material data
sigma_a = 0.999 * np.ones(ncells)
sigma_s = 0.001 * np.ones(ncells)


def create_source_particles():
    """ This function generates source particles and assigns them their properties.
        This should run every time-step.
    """
    global particle_prop
    for icell in range(ncells):
        # Create position, angle, time, and scattering arrays
        x_positions = nodepos[icell] + (np.arange(Nx) + 0.5) * dx / Nx
        angles = -1 + (np.arange(Nmu) + 0.5) * 2 / Nmu
        emission_times = time + (np.arange(Nt) + 0.5) * dt / Nt
        xi_values = (np.arange(Nxi) + 0.5) / Nxi

        # Assign energy-weights
        n_source_ptcls = Nx * Nmu * Nt * Nxi
        nrg = c * sigma_a[icell] * a * (temp[icell] ** 4) * dt * dx / n_source_ptcls
        startnrg = nrg
        # Create particles and add them to global list
        origin = icell
        for xpos in x_positions:
            for mu in angles:
                for ttt in emission_times:
                    for xi in xi_values:
                        particle_prop.append([origin, ttt, icell, xpos, mu, xi, nrg, startnrg])


def create_census_particles():
    """ This function creates the census particles for the first time-step."""
    global particle_prop
    for icell in range(ncells):
        # Create position, angle, and scattering arrays
        x_positions = nodepos[icell] + (np.arange(Nx) + 0.5) * dx / Nx
        angles = -1 + (np.arange(Nmu) + 0.5) * 2 / Nmu
        xi_values = (np.arange(Nxi) + 0.5) / Nxi

        # Assign energy-weights
        n_census_ptcls = Nx * Nmu * Nxi
        nrg = a * (radtemp[icell] ** 4) * dx / n_census_ptcls
        startnrg = nrg

        # Assign origin and time of emission
        ttt = time
        origin = icell

        # Create particles and add them to the global list
        for xpos in x_positions:
            for mu in angles:
                for xi in xi_values:
                    particle_prop.append([origin, ttt, icell, xpos, mu, xi, nrg, startnrg])
                    census_grid.append([icell, xpos, mu, xi, 0])


def advance_particles():
    """ This function takes the global particle list and advances
    them to the end of the time-step. Assume left BC is reflecting and right BC is vacuum. """
    # Create angle, and scattering arrays
    angles = -1 + (np.arange(Nmu) + 0.5) * 2 / Nmu
    xi_values = (np.arange(Nxi) + 0.5) / Nxi

    global particle_prop, scatter_counter
    tempnrgdep = np.zeros(ncells)
    endsteptime = time + dt
    nrgdep = np.zeros(ncells)
    top_cell = ncells - 1

    for iptcl in range(len(particle_prop)):
        (ttt, icell, xpos, mu, xi, nrg, startnrg) = particle_prop[iptcl][1:8]

        while True:
            if mu > 0.0:
                dist_b = (nodepos[icell + 1] - xpos) / abs(mu)
            else:
                dist_b = (xpos - nodepos[icell]) / abs(mu)
            dist_cen = c * (endsteptime - ttt)
            dist_scatter = -np.log(xi) / sigma_s[icell]

            dist = min(dist_b, dist_cen, dist_scatter)

            newnrg = nrg * np.exp(-sigma_a[icell] * dist)
            tempnrgdep[icell] += (nrg - newnrg)

            xpos += mu * dist
            ttt += dist * invc
            nrg = newnrg
            if dist == dist_b:
                if mu > 0:
                    if icell == top_cell:  # Particle escapes right boundary
                        # Flag particle for later destruction
                        particle_prop[iptcl][6] = -1.0
                        break
                    icell += 1
                if mu < 0:
                    if icell != 0:
                        icell -= 1
                    if icell == 0:  # Reflecting BC on left boundary
                        mu = -mu
            if dist == dist_cen:
                particle_prop[iptcl][1:6] = (ttt, icell, xpos, mu, xi, nrg)
                break
            # If event was a scatter, also update xi and mu
            if dist == dist_scatter:
                scatter_counter += 1
                # Update mu
                mu_index = np.where(angles == mu)[0]
                if len(mu_index) > 0:
                    mu_index = mu_index[0]
                    mu_index = (mu_index + 1) % len(angles)
                    mu = angles[mu_index]

                # Update xi
                xi_index = np.where(xi_values == xi)[0][0]
                xi_index = (xi_index + 1) % len(xi_values)
                xi = xi_values[xi_index]
    nrgdep[:] = tempnrgdep[:]
    return nrgdep


def population_control():
    global particle_prop
    # The energy in the particles before population control
    nrgprepopctrl = sum(item[6] for item in particle_prop)
    # print(f'Energy in the particles pre population control = {nrgprepopctrl}')
    # Make a copy of the census grid
    census_grid_popctrl = census_grid.copy()

    # Reset the nrg term to zero for all energy entries in census_grid_popctrl
    for entry in census_grid_popctrl:
        entry[4] = 0

    for particle in particle_prop:
        icell, xpos, mu, xi, nrg = particle[2], particle[3], particle[4], particle[5], particle[6]

        # Calculate ix and imu for the particle
        position_fraction = (xpos - nodepos[icell]) / dx
        ix = int(position_fraction * Nx)
        ix = min(max(ix, 0), Nx - 1)

        angle_fraction = (mu + 1) / 2
        imu = int(angle_fraction * Nmu)
        imu = min(max(imu, 0), Nmu - 1)

        xi_fraction = xi / 1
        ixi = int(xi_fraction * Nxi)
        ixi = min(max(ixi, 0), Nxi - 1)

        # Calculate the linear index for census_grid
        linear_index = icell * Nx * Nmu * Nxi + ix * Nmu * Nxi + imu * Nxi + ixi
        census_grid_popctrl[linear_index][4] += nrg  # Accumulate energy in the nearest census particle

    particle_count_before = len(particle_prop)
    # print(f'Particle count before population control: {particle_count_before}')

    # Remove old particles from particle_prop
    particle_prop = []

    # Add new particles from census_grid_popctrl
    for entry in census_grid_popctrl:
        icell = entry[0]
        xpos = entry[1]
        mu = entry[2]
        xi = entry[3]
        nrg = entry[4]

        # Insert new parameters into each particle entry
        origin = entry[0]  # icell from census grid
        ttt = time  # current time in the simulation
        startnrg = nrg  # energy from census grid

        # Append updated particle entry to particle_prop
        particle_prop.append([origin, ttt, icell, xpos, mu, xi, nrg, startnrg])

    particle_count_after = len(particle_prop)
    # print(f'Particle count after population control: {particle_count_after}')
    # energy in the particles post population control
    nrgpostpopctrl = sum(item[6] for item in particle_prop)
    # print(f'Energy in the particles post population control = {nrgpostpopctrl}')


def clean_particles():
    """Tidy up the particle list by removing leaked particles."""
    # These had their energy set to -1 to flag them
    for iptcl in range(len(particle_prop) - 1, 0, -1):
        if particle_prop[iptcl][6] < 0.0:
            del particle_prop[iptcl]


def surface_source():
    global particle_prop
    e_surf = sb * bcon_temp ** 4 * dt

    # Create source particles for the surface
    xpos = 0.0
    angles = -1 + (np.arange(Nmu) + 0.5) * 2 / Nmu
    emission_times = time + (np.arange(Nt) + 0.5) * dt / Nt
    xi_values = (np.arange(Nxi) + 0.5) / Nxi

    # Create energy-weights
    n_source_ptcls = len(angles) * len(emission_times) * len(xi_values)
    nrg = e_surf / n_source_ptcls
    startnrg = nrg
    icell = 0  # starts in leftmost cell
    origin = icell
    # Create particles and add them to global list
    for mu in angles:
        for ttt in emission_times:
            for xi in xi_values:
                particle_prop.append([origin, ttt, icell, xpos, mu, xi, nrg, startnrg])


alpha = 4 * a
# Set Boundary Condition Temperature
bcon_temp = 1.0  # keV

# Set initial material temperature field
tmp0 = 0.01  # keV
temp[:] = tmp0

# Set initial radiation temperature field
radtmp0 = 0.01  # keV
radtemp[:] = radtmp0

# Set Heat Capacity
b = alpha * temp ** 3

# Create global particle list and begin time
time = 0.0
particle_prop = []

# Start the problem
scatter_counter = 0
census_grid = []
create_census_particles()

for step in range(1, ns+1):
    print(f'Step:{step}')
    nrgdep = np.zeros(ncells)
    energy_emitted = c * sigma_a * a * temp ** 4 * dt * dx

    # source new particles
    create_source_particles()  # from the cell temperature
    surface_source()  # from the boundary condition temperature
    # Advance particles
    energy_deposited = advance_particles()
    #print(energy_deposited)
    clean_particles()

    # update time
    time += dt

    # Update Material Temperature
    nrginc = energy_deposited - energy_emitted
    #print(f'nrginc = {nrginc}')
    temp += b ** -1 * nrginc
    #print(f'New Temperature field: {temp}')

    # Update actual_energy_remaining for each cell
    actual_energy_remaining = np.zeros(ncells)  # Initialize actual_energy_remaining as an array of zeros
    for particle in particle_prop:
        cell_index = particle[2]
        actual_energy_remaining[cell_index] += particle[6]

    # update radiation temperature
    radtemp[:] = (actual_energy_remaining / a / dx) ** (1 / 4)

    # update heat capacity
    b = alpha * temp ** 3

    # Apply population control as needed
    if len(particle_prop) > 1E6:
        population_control()


#print(f'Scatter counter = {scatter_counter}')
plt.figure()
plt.plot(cellpos, temp, label='Material Temperature', color='blue')
plt.plot(cellpos, radtemp, label='Radiation Temperature', color='red')
plt.xlabel('Position (cm)')
plt.xlim(nodepos[0], nodepos[-1])
plt.ylabel('Temperature (keV)')
plt.title('Temperature')
plt.grid(True)
plt.legend()
plt.show()
